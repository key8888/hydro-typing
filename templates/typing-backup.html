{% extends "layout/basic.html" %}
{% block content %}
<style>
  /* ===== ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« ===== */
  .typing-wrap {
    position: relative;
    text-align: center;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  }

  .typing-hud {
    position: absolute;
    left: 0.5rem;
    top: -0.25rem;
    font-size: .9rem;
    color: #666;
    user-select: none;
  }

  .typing-word {
    display: inline-block;
    font-size: 2.2rem;
    letter-spacing: .05em;
    line-height: 1.6;
    margin: 1.25rem 0 .25rem;
  }

  .typing-meaning {
    margin: 0 0 .75rem;
    font-size: 1.05rem;
    color: #4b5563;
    /* gray-600 */
  }

  .char {
    padding: 0 .02em;
    border-radius: .25rem;
  }

  .char--todo {
    color: #222;
    opacity: .6;
  }

  .char--correct {
    color: #15803d;
  }

  /* green-700 */
  .char--wrong {
    color: #b91c1c;
  }

  /* red-700  */
  .char--current {
    text-decoration: underline;
    text-underline-offset: .2em;
  }

  .typing-end {
    display: none;
    margin-top: 1.25rem;
  }

  .typing-end__score {
    font-size: 2rem;
    font-weight: 700;
    margin: .25rem 0 1rem;
  }

  /* ===== å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆè¦‹ã‚„ã™ã•é‡è¦–ï¼‰ ===== */
  .history-card {
    margin-top: 2rem;
    border-radius: 14px;
    border: 1px solid #e5e7eb;
    /* gray-200 */
    box-shadow: 0 8px 24px rgba(0, 0, 0, .06);
    overflow: hidden;
  }

  .history-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: .9rem 1rem;
    background: linear-gradient(180deg, #fafafa, #f5f5f5);
    border-bottom: 1px solid #e5e7eb;
  }

  .history-title {
    font-size: 1.05rem;
    font-weight: 600;
    color: #111827;
    margin: 0;
  }

  .history-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
  }

  .history-table thead th {
    text-align: left;
    font-size: .9rem;
    color: #6b7280;
    /* gray-500 */
    font-weight: 600;
    padding: .7rem 1rem;
    border-bottom: 1px solid #e5e7eb;
    background: #fff;
    position: sticky;
    top: 0;
  }

  .history-table tbody tr:nth-child(odd) {
    background: #fcfcfd;
  }

  .history-table tbody tr:nth-child(even) {
    background: #ffffff;
  }

  .history-table td {
    padding: .75rem 1rem;
    font-size: .95rem;
    color: #111827;
  }

  .history-empty {
    padding: 1rem;
    color: #6b7280;
    text-align: center;
  }

  .section__header {
    margin-bottom: .25rem;
  }
</style>

<script src="/public/hello.js"></script>

<div class="row">
  <div class="medium-12 columns">
    <!-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°æœ¬ä½“ -->
    <div class="section">
      <div class="section__header">
        <h1 class="section__title">{{ _('Typing Practice') }}</h1>
      </div>

      <div class="section__body typing-wrap">
        <!-- æ®‹ã‚Šå˜èªæ•° HUD ã®ãã°ã«è¿½åŠ  -->
        <div style="position:absolute; right:.5rem; top:-.25rem; font-size:.9rem; color:#666;">
          <label style="cursor:pointer; user-select:none;">
            <input id="tts-toggle" type="checkbox" checked style="vertical-align:middle; margin-right:.25rem;">
            ğŸ”Š ç™ºéŸ³
          </label>
        </div>


        <!-- æ®‹ã‚Šå˜èªæ•° HUD -->
        <div id="hud-remaining" class="typing-hud">Left: - / -</div>

        <!-- å˜èªè¡¨ç¤º -->
        <div id="word-display" class="typing-word"></div>
        <!-- æ—¥æœ¬èªè¨³ -->
        <div id="meaning-display" class="typing-meaning"></div>

        <!-- çµ‚äº†ç”»é¢ï¼ˆWPMè¡¨ç¤ºï¼†ä¿å­˜ãƒ•ã‚©ãƒ¼ãƒ ï¼‰ -->
        <div id="end-screen" class="typing-end">
          <h2 class="section__title" style="margin-bottom:.25rem;">{{ _('Finished!') }}</h2>
          <div class="typing-end__score">
            WPM: <span id="final-wpm">0</span>
          </div>
          <form id="score-form" method="post" action="/typing" style="margin-top:.5rem;">
            <input type="hidden" name="score" id="score-input">
            <button type="submit" class="rounded primary button">{{ _('Save score') }}</button>
          </form>
          <div style="margin-top:.5rem; color:#6b7280; font-size:.9rem;">
            <span>Chars: <span id="final-chars">0</span></span> Â·
            <span>Time: <span id="final-time">0.0</span>s</span>
          </div>
        </div>
      </div>
    </div>

    <!-- å±¥æ­´ã‚«ãƒ¼ãƒ‰ -->
    <div class="section">
      <div class="history-card">
        <div class="history-header">
          <h2 class="history-title">{{ _('History') }}</h2>
        </div>
        <div>
          {% if history and history.length %}
          <table class="history-table">
            <thead>
              <tr>
                <th>{{ _('Date') }}</th>
                <th>WPM</th>
              </tr>
            </thead>
            <tbody id="history-body">
              {% for h in history %}
              <tr>
                <td class="js-date">{{ h.createdAt }}</td>
                <td><strong>{{ h.score }}</strong></td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
          {% else %}
          <div class="history-empty">ã¾ã å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>
          {% endif %}
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  /* ====== Web Speech (TTS) ç™ºéŸ³ ====== */
  let ttsEnabled = true;
  let ttsVoice = null;

  // è¨€èª: è‹±èªç³»ã‚’å„ªå…ˆã—ã¦é¸ã¶
  function pickEnglishVoice(voices) {
    if (!voices || !voices.length) return null;
    const byLang = voices.filter(v => v.lang && v.lang.toLowerCase().startsWith('en'));
    // åå‰ã§ãã‚Œã£ã½ã„ã®ã‚’å„ªå…ˆï¼ˆä»»æ„ï¼‰
    const preferNames = ['Google US English', 'Samantha', 'Alex', 'Microsoft Aria', 'Microsoft Zira'];
    for (const name of preferNames) {
      const hit = byLang.find(v => v.name.includes(name));
      if (hit) return hit;
    }
    return byLang[0] || voices[0];
  }

  function initVoices() {
    try {
      const voices = window.speechSynthesis?.getVoices?.() || [];
      ttsVoice = pickEnglishVoice(voices);
    } catch { }
  }

  // éŸ³å£°å†ç”Ÿ
  function speakWord(text) {
    if (!ttsEnabled) return;
    if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;
    if (!text) return;

    // ç›´å‰ã®ç™ºè©±ã‚’æ­¢ã‚ã¦ã‹ã‚‰å†ç”Ÿï¼ˆé‡ãªã‚Šé˜²æ­¢ï¼‰
    try { window.speechSynthesis.cancel(); } catch { }

    const utt = new SpeechSynthesisUtterance(text);
    if (ttsVoice) utt.voice = ttsVoice;
    // èãå–ã‚Šã‚„ã™ã„èª¿æ•´ï¼ˆãŠå¥½ã¿ã§ï¼‰
    utt.rate = 0.9;  // å°‘ã—ã‚†ã£ãã‚Š
    utt.pitch = 1.0;
    utt.volume = 1.0;

    try { window.speechSynthesis.speak(utt); } catch { }
  }

  // ç«¯æœ«ã«ã‚ˆã£ã¦ã¯ voices ãŒéåŒæœŸãƒ­ãƒ¼ãƒ‰
  if ('speechSynthesis' in window) {
    initVoices();
    window.speechSynthesis.addEventListener?.('voiceschanged', initVoices);
  }

  // ãƒˆã‚°ãƒ«
  document.getElementById('tts-toggle')?.addEventListener('change', (e) => {
    ttsEnabled = e.target.checked;
    if (!ttsEnabled && window.speechSynthesis) {
      try { window.speechSynthesis.cancel(); } catch { }
    } else {
      // æœ‰åŠ¹åŒ–æ™‚ã€ç¾åœ¨ã®å˜èªã‚’å¾©å”±ã—ã¦ã‚ã’ã‚‹ã¨è¦ªåˆ‡
      const cur = items[currentWordIndex];
      if (cur?.word) speakWord(cur.word);
    }
  });



  /* ====== å˜èªã®è¡¨ç¤ºãŠã‚ˆã³ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã®å‹•ä½œé–¢é€£ ====== */
  // [{word, meaning}] ãŒæ¥ã‚‹
  const items = {{ words | safe }};
  const totalWords = items.length;

  let currentWordIndex = 0;
  let currentCharIndex = 0;
  let correctChars = 0;

  let startedAt = null;
  let finishedAt = null;
  let waitingNext = false;

  const hudRemaining = document.getElementById('hud-remaining');
  const wordDisplay = document.getElementById('word-display');
  const meaningEl = document.getElementById('meaning-display');
  const endScreen = document.getElementById('end-screen');
  const finalWpmEl = document.getElementById('final-wpm');
  const finalCharsEl = document.getElementById('final-chars');
  const finalTimeEl = document.getElementById('final-time');
  const scoreInput = document.getElementById('score-input');

  function pad2(n) { return n.toString().padStart(2, '0'); }

  function renderRemaining() {
    const left = Math.max(totalWords - currentWordIndex, 0);
    hudRemaining.textContent = `Left: ${left} / ${totalWords}`;
  }

  function renderWord(showWrong = false) {
    const cur = items[currentWordIndex] || { word: '', meaning: '' };
    const word = cur.word || '';
    const meaning = cur.meaning || '';

    let html = '';
    for (let i = 0; i < word.length; i++) {
      const ch = word[i];
      if (i < currentCharIndex) {
        html += `<span class="char char--correct">${ch}</span>`;
      } else if (i === currentCharIndex) {
        const wrong = showWrong;
        html += `<span class="char ${wrong ? 'char--wrong' : 'char--todo'} char--current">${ch}</span>`;
      } else {
        html += `<span class="char char--todo">${ch}</span>`;
      }
    }
    wordDisplay.innerHTML = html;
    meaningEl.textContent = meaning; // â† æ—¥æœ¬èªè¨³ã¯ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤º
    renderRemaining();
  }

  function finish() {
    finishedAt = Date.now();
    const elapsedMs = Math.max(1, finishedAt - (startedAt ?? finishedAt));
    const minutes = elapsedMs / 60000;
    const wpm = Math.round((correctChars / 5) / minutes);

    wordDisplay.style.display = 'none';
    meaningEl.style.display = 'none';
    endScreen.style.display = 'block';

    finalWpmEl.textContent = String(wpm);
    finalCharsEl.textContent = String(correctChars);
    finalTimeEl.textContent = (elapsedMs / 1000).toFixed(1);
    scoreInput.value = String(wpm);
  }

  function nextWord() {
    currentWordIndex++;
    currentCharIndex = 0;
    waitingNext = false;
    if (currentWordIndex >= totalWords) {
      finish();
    } else {
      renderWord(false);
    }
  }

  document.addEventListener('keydown', (e) => {
    if (waitingNext || endScreen.style.display === 'block') return;

    // æœ€åˆã®ã‚­ãƒ¼ã§è¨ˆæ™‚é–‹å§‹ï¼ˆShift ç­‰ã¯é™¤å¤–ï¼‰
    if (!startedAt && e.key && e.key.length === 1) {
      startedAt = Date.now();

      // â† åˆå›ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã®æ©Ÿä¼šã§ç™ºéŸ³ï¼ˆiOSã®è‡ªå‹•å†ç”Ÿåˆ¶é™ã«å¯¾å¿œï¼‰
      const cur0 = items[currentWordIndex];
      if (cur0?.word) speakWord(cur0.word);
    }

    const cur = items[currentWordIndex] || { word: '' };
    const word = cur.word || '';
    const expected = word[currentCharIndex];
    if (!expected) return;

    // 1æ–‡å­—ã‚­ãƒ¼ä»¥å¤–ã¯ç„¡è¦–ï¼ˆShift/Alt/Ctrlãªã©ï¼‰
    if (!e.key || e.key.length !== 1) return;

    const pressed = e.key;
    if (pressed.toLowerCase() === expected.toLowerCase()) {
      currentCharIndex++;
      correctChars++;
      renderWord(false);

      if (currentCharIndex === word.length) {
        waitingNext = true;
        // 1ç§’è¦‹ã›ãŸå¾Œã€æ¬¡ã®å˜èªã¸
        setTimeout(() => {
          nextWord();
          // æ¬¡ã®å˜èªã«åˆ‡ã‚Šæ›¿ãˆãŸç›´å¾Œã«ç™ºéŸ³
          const curNext = items[currentWordIndex];
          if (curNext?.word) speakWord(curNext.word);
        }, 1000);
      }
    } else {
      renderWord(true); // ç¾åœ¨æ–‡å­—ã‚’èµ¤ã§è¡¨ç¤º
    }
  });

  // åˆæœŸæç”»
  renderWord(false);

  /* å±¥æ­´ã®æ—¥ä»˜ã‚’ "Sun Oct 05 2025 23:32" ã«æ•´å½¢ */
  (function formatHistoryDates() {
    const cells = document.querySelectorAll('.js-date');
    const weekday = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function fmt(d) {
      return `${weekday[d.getDay()]} ${month[d.getMonth()]} ${pad2(d.getDate())} ${d.getFullYear()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
    }
    for (const td of cells) {
      const raw = td.textContent?.trim() ?? '';
      const d = new Date(raw);
      if (!isNaN(d.getTime())) td.textContent = fmt(d);
    }
  })();
</script>
{% endblock %}